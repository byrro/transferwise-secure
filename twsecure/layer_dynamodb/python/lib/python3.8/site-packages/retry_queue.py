#!/usr/bin/python3 Python3
from collections import namedtuple
from dataclasses import dataclass
from hashlib import sha1
import logging
import os
import queue
from typing import Any, NamedTuple
import uuid


log = logging.getLogger(os.environ.get('LOGGER_NAME', 'DYNAMODB_LOGGER'))


class TooManyRetriesException(Exception):
    def __init__(self, retry_count, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.retry_count = retry_count

    def __str__(self):
        return f'Item was retried too many times: {self.retry_count}'


class UnknownItemException(Exception):
    pass


class RetryQueueItem:
    def __init__(self, data: Any) -> None:
        self.data: Any = data
        self.uuid: str = str(uuid.uuid5(uuid.NAMESPACE_X500, str(self.data)))


class RetryLimitQueue(queue.Queue):

    def __init__(self, max_retries: int = 0, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.max_retries = max_retries
        self.retry_map = {}  # hashmap between item.uuid and retry count

    def _put(self, item: Any) -> None:
        '''Retry-aware implementation of Queue._put() method'''
        item = RetryQueueItem(item)

        if item.uuid not in self.retry_map.keys():
            self.retry_map[item.uuid] = 0

        retry_count = self.retry_map[item.uuid]

        if retry_count >= self.max_retries:
            raise TooManyRetriesException(retry_count)

        self.queue.append(item)

    def _get(self) -> Any:
        '''Retry-aware implementation of the Queue._get() method'''
        item = self.queue.popleft()
        self.retry_map[item.uuid] += 1
        return item.data

    def item_retry_count(self, item: Any) -> int:
        item = RetryQueueItem(item)

        if item.uuid not in self.retry_map.keys():
            raise LookupError(f'Item not found in the Queue ({str(item)})')

        return self.retry_map[item.uuid]
