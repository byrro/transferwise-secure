#!/usr/bin/python3 Python3
import json
import logging
import os
from typing import Tuple

import boto3


log = logging.getLogger(os.environ.get('LOGGER_NAME', 'SECRET_LOGGER'))

# Threshold to cut secrets and mask for safe printing/logging
SECRET_CUT_THRESHOLD = 5

# Default Secret ARN from the environment variables
SECRET_ARN = os.environ.get('SECRET_ARN')

# Name of environment variable to hold secret value transiently; this avoids
# unnecessary calls to the SecretsManager API across different Lambda requests
SECRET_VALUE_ENV_VAR = 'TRANSIENT_SECRET_VALUE'


class GetSecretValueFailureException(Exception):
    pass


def get_secrets(
        secret_arn: str = SECRET_ARN,
        client: 'boto3.client' = None,
        ) -> dict:
    '''Retrive a secret value from AWS SecretsManager'''
    try:
        if client is None:
            client = boto3.client(service_name='secretsmanager')

        # Only fallback to SecretsManager if the secret is not available from
        # previous Lambda requests
        if SECRET_VALUE_ENV_VAR not in os.environ.keys():
            log.info('## Secret value not available in env vars\n')

            r = client.get_secret_value(SecretId=secret_arn)

            os.environ[SECRET_VALUE_ENV_VAR] = r['SecretString']
        
        else:
            log.info('## Secret value was already available in env vars\n')

    except (KeyError, ValueError) as e:
        raise GetSecretValueFailureException('Failed to extract secret') from e

    except boto3.exceptions.Boto3Error as boto3exc:
        log.error('Failed to retrieve secret from AWS SecretsManager\n')
        raise boto3exc

    else:
        return json.loads(os.environ.get(SECRET_VALUE_ENV_VAR))


def print_secret(secret: str) -> None:
    '''Safely print a secret, showing a small portion and masking the rest'''
    print(mask_secret(secret))
    return None


def mask_secret(secret: str) -> str:
    '''Generate a masked version of a secret'''
    cut_at, length = calculate_secret_cut(secret)
    return secret[0:cut_at] + '*'*(len(secret)-length)


def calculate_secret_cut(
        secret: str,
        cut_threshold: int = SECRET_CUT_THRESHOLD,
        ) -> Tuple[int]:
    '''Calculate where to cut a secret for masking and safe printing/logging

    Input: provide a secret (str) and, optionally, a cut threshold (int)

    It will calculate where to cut the secret, preventing accidental disclosure
    of too short secrets.

    Returns a tuple with two integers:
    - 0: "cut_at"
    - 1:"length"

    Usage:
    - Cut a section that will be disclosed: secret[0:cut_at]
    - Mask the rest of the secret: "*" * (len(secret) - length)
    - The final masked secret is the concatenation of these two strings
    '''
    if len(secret) <= cut_threshold:
        return 0
    return cut_threshold-1, cut_threshold
